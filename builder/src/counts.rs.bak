// std
use std::collections::HashMap;

// ext

// int

// Used by the builder to track values

pub struct Count {
	pub uuids: Vec<usize>,
	pub start: usize,
	pub end: usize,
}

impl Count {
	pub fn new() -> Self {
		Self {
			uuids: Vec::new(),
			start: 0,
			end: 0,
		}
	}
}

pub struct Counts {
	pub _counts: HashMap<String, Count>,
	// pub challenges: Vec<usize>,
	// pub challenges_start: usize,
	// pub challenges_end: usize,
	// pub challenge_types: Vec<usize>,
	// pub challenge_types_start: usize,
	// pub challenge_types_end: usize,
	// pub conversations: Vec<usize>,
	// pub conversations_start: usize,
	// pub conversations_end: usize,
	// pub exits: Vec<usize>,
	// pub exits_start: usize,
	// pub exits_end: usize,
	pub inventory_uuid: usize,
	// pub items: Vec<usize>,
	// pub items_start: usize,
	// pub items_end: usize,
	// pub locations: Vec<usize>,
	// pub locations_start: usize,
	// pub locations_end: usize,
	// pub people: Vec<usize>,
	// pub people_start: usize,
	// pub people_end: usize,
	// pub vending: Vec<usize>,
	pub vending_ether_uuid: usize,
	// pub vending_start: usize,
	// pub vending_end: usize,
	pub starting_location_uuid: usize,
	pub total: usize,
}

impl Counts {
	pub fn new() -> Self {
		Self {
			// challenges: Count,
			_counts: HashMap::new(),
			// challenges: Vec::new(),
			// challenges_start: 0,
			// challenges_end: 0,
			// challenge_types: Vec::new(),
			// challenge_types_start: 0,
			// challenge_types_end: 0,
			// conversations: Vec::new(),
			// conversations_start: 0,
			// conversations_end: 0,
			// exits: Vec::new(),
			// exits_start: 0,
			// exits_end: 0,
			inventory_uuid: 0,
			// items: Vec::new(),
			// items_start: 0,
			// items_end: 0,
			// locations: Vec::new(),
			// locations_start: 0,
			// locations_end: 0,
			// people: Vec::new(),
			// people_start: 0,
			// people_end: 0,
			// vending: Vec::new(),
			vending_ether_uuid: 0,
			// vending_start: 0,
			// vending_end: 0,
			starting_location_uuid: 0,
			total: 0,
		}
	}

	pub fn add(&mut self, name: &str, uuid: usize) {
		let n = String::from(name);
		if !self._counts.contains_key(&n) {
			self._counts.insert(n.clone(), Count::new());
		}

		self._counts.get_mut(&n).unwrap().uuids.push(uuid);
		self.total = self.total + 1;
	}

	pub fn get(&mut self, name: &str) -> &mut Count {
		return self._counts.get_mut(&String::from(name)).unwrap();
	}

	pub fn in_range_of(&self, index: usize) -> String {
		for (name, count) in self._counts.iter() {
			if count.start <= index && count.end > index {
				return name.clone();
			}
		}

		return String::new();
	}

	pub fn set_start(&mut self, name: &str, index: usize) {
		self._counts.get_mut(&String::from(name)).unwrap().start = index;
	}

	pub fn set_end(&mut self, name: &str, index: usize) {
		self._counts.get_mut(&String::from(name)).unwrap().end = index;
	}

	pub fn size(&self, name: &str) -> usize {
		// return self._counts.get_mut(String::from(name)).unwrap().end -
		// 	self._counts.get_mut(String::from(name)).unwrap().start;
		return self._counts.get(&String::from(name)).unwrap().uuids.len();
	}

	pub fn total(&mut self) -> usize {
		let mut total = 0;
		for (_, count) in &self._counts {
			total = total + count.uuids.len();
		}

		return total;
	}
}
